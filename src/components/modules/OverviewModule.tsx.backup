'use client'

import { useState, useEffect } from 'react'
import { MetricCard } from '@/components/ui/metric-card'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { YieldCurveChart } from '@/components/charts/YieldCurveChart'

const STRATEGY_TYPES = [
    'æŒ‡å¢',
    'ä¸­æ€§',
    'CTA',
    'T0',
    'å¥—åˆ©',
    'é‡é€‰',
    'æ··åˆ',
    'æ‹©æ—¶',
    'æœŸæƒ',
    'å®è§‚',
    'æ‹©æ—¶å¯¹å†²',
    'å¯è½¬å€º'
]

interface OverviewModuleProps {
    data: any
    loading: boolean
    error: string | null
}

export function OverviewModule({ data: initialData, loading: initialLoading, error: initialError }: OverviewModuleProps) {
    const [data, setData] = useState<any>(initialData)
    const [loading, setLoading] = useState(initialLoading)
    const [selectedStrategy, setSelectedStrategy] = useState<string>('all')

    // Fetch full history data when component mounts
    useEffect(() => {
        const loadFullData = async () => {
            try {
                setLoading(true)
                const res = await fetch('/api/funds?type=excluded-fof&includeHistory=true')
                const json = await res.json()
                if (json.success) {
                    const { funds, strategyStats, managerStats } = json.data

                    // Calculate aggregated metrics
                    const totalAssets = funds.reduce((sum: number, f: any) => sum + (f.cost || 0), 0)
                    const todayReturn = funds.reduce((sum: number, f: any) => sum + (f.daily_pnl || 0), 0)

                    // Calculate weighted average returns
                    const totalCost = totalAssets || 1
                    const weeklyReturn = funds.reduce((sum: number, f: any) => sum + (f.weekly_return || 0) * (f.cost || 0), 0) / totalCost
                    const annualReturn = funds.reduce((sum: number, f: any) => sum + (f.yearly_return || 0) * (f.cost || 0), 0) / totalCost
                    const totalReturn = funds.reduce((sum: number, f: any) => sum + (f.cumulative_return || 0) * (f.cost || 0), 0) / totalCost

                    // Map strategy stats
                    const strategyData = strategyStats.map((s: any) => ({
                        strategy: s.strategy,
                        value: s.total_cost || 0,
                        count: s.fund_count
                    }))

                    setData({
                        funds,
                        strategyStats,
                        managerStats,
                        totalAssets,
                        todayReturn,
                        weeklyReturn,
                        annualReturn,
                        totalReturn,
                        strategyData
                    })
                }
            } catch (err) {
                console.error('Failed to load full history:', err)
            } finally {
                setLoading(false)
            }
        }
        loadFullData()
    }, [])

    if (loading) {
        return (
            <div className="flex items-center justify-center h-96">
                <div className="text-center">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                    <p className="text-gray-600">æ­£åœ¨åŠ è½½æ•°æ®...</p>
                </div>
            </div>
        )
    }

    if (initialError || !data) {
        return (
            <div className="flex items-center justify-center h-96">
                <div className="text-center">
                    <div className="text-red-600 text-6xl mb-4">âš ï¸</div>
                    <p className="text-gray-600 text-lg mb-4">{initialError || 'æ•°æ®åŠ è½½å¤±è´¥'}</p>
                </div>
            </div>
        )
    }

    // Helper to get the Friday of the week for a given date
    const getWeekEndingDate = (dateStr: string) => {
        const date = new Date(dateStr)
        const day = date.getDay()
        const diff = date.getDate() - day + (day === 0 ? -2 : 5) // Adjust to Friday
        const friday = new Date(date.setDate(diff))
        return friday.toISOString().split('T')[0]
    }

    // Process data for the chart
    const getChartData = () => {
        if (!data.funds) return { chartData: [], series: [] }

        // Filter funds based on selected strategy
        const filteredFunds = selectedStrategy === 'all'
            ? data.funds
            : data.funds.filter((f: any) => f.strategy === selectedStrategy)

        // ---------------------------------------------------------
        // Scenario 1: "All Strategies" - Aggregate by Strategy
        // ---------------------------------------------------------
        if (selectedStrategy === 'all') {
            // We will collect data into a map: Date -> { Strategy -> { sumReturn, sumYearly, count } }
            const weeklyMap = new Map<string, {
                date: string,
                strategies: Map<string, { sumReturn: number, sumYearly: number, count: number }>
            }>()

            data.funds.forEach((fund: any) => {
                if (!fund.strategy) return
                if (!fund.history || fund.history.length === 0) return

                // Filter for 2025 data
                const history2025 = fund.history
                    .filter((h: any) => h.date >= '2025-01-01')
                    .sort((a: any, b: any) => a.date.localeCompare(b.date))

                if (history2025.length === 0) return

                const baseNav = history2025[0].cumulative_nav

                // 1. Identify the value for each week for this fund (take the last available day of the week)
                const fundWeeklyValues = new Map<string, any>()
                history2025.forEach((h: any) => {
                    const dateStr = h.date.split('T')[0]
                    const weekDate = getWeekEndingDate(dateStr)

                    // Overwrite: later days in the week will replace earlier ones
                    fundWeeklyValues.set(weekDate, {
                        cumulative_nav: h.cumulative_nav,
                        daily_return: h.daily_return || 0
                    })
                })

                // 2. Add this fund's weekly values to the global aggregation
                fundWeeklyValues.forEach((val, weekDate) => {
                    if (!weeklyMap.has(weekDate)) {
                        weeklyMap.set(weekDate, { date: weekDate, strategies: new Map() })
                    }
                    const weekData = weeklyMap.get(weekDate)!

                    if (!weekData.strategies.has(fund.strategy)) {
                        weekData.strategies.set(fund.strategy, { sumReturn: 0, sumYearly: 0, count: 0 })
                    }
                    const stratStats = weekData.strategies.get(fund.strategy)!

                    const normalizedReturn = baseNav ? (val.cumulative_nav - baseNav) / baseNav : 0

                    stratStats.sumReturn += normalizedReturn
                    stratStats.sumYearly += normalizedReturn
                    stratStats.count += 1
                })
            })

            // 3. Flatten map to chartData array
            const chartData = Array.from(weeklyMap.values())
                .map(item => {
                    const point: any = { date: item.date }
                    item.strategies.forEach((stats, strategy) => {
                        point[strategy] = stats.sumReturn / stats.count
                        point[`${strategy}_yearly`] = stats.sumYearly / stats.count
                    })
                    return point
                })
                .sort((a, b) => a.date.localeCompare(b.date))

            // 4. Build Series
            const strategyColors: Record<string, string> = {
                'æŒ‡å¢': '#3b82f6',
                'ä¸­æ€§': '#10b981',
                'CTA': '#f59e0b',
                'T0': '#8b5cf6',
                'å¥—åˆ©': '#ec4899',
                'é‡é€‰': '#06b6d4',
                'æ··åˆ': '#f97316',
                'æ‹©æ—¶': '#14b8a6',
                'æœŸæƒ': '#6366f1',
                'å®è§‚': '#84cc16',
                'æ‹©æ—¶å¯¹å†²': '#8b5cf6',
                'å¯è½¬å€º': '#d946ef'
            }

            const series = Array.from(new Set(data.funds.map((f: any) => f.strategy).filter(Boolean))).map((strategy: any) => ({
                id: strategy,
                name: strategy,
                color: strategyColors[strategy] || `hsl(${Math.random() * 360}, 70%, 50%)`,
                strokeWidth: 2.5,
                yearlyKey: `${strategy}_yearly`
            }))

            return { chartData, series }
        }

        // ---------------------------------------------------------
        // Scenario 2: Specific Strategy - Individual Funds
        // ---------------------------------------------------------
        const weeklyMap = new Map<string, any>()

        filteredFunds.forEach((fund: any) => {
            if (!fund.history || fund.history.length === 0) return

            const history2025 = fund.history
                .filter((h: any) => h.date >= '2025-01-01')
                .sort((a: any, b: any) => a.date.localeCompare(b.date))

            if (history2025.length === 0) return

            const baseNav = history2025[0].cumulative_nav

            // Group by week
            history2025.forEach((h: any) => {
                const dateStr = h.date.split('T')[0]
                const weekDate = getWeekEndingDate(dateStr)

                if (!weeklyMap.has(weekDate)) {
                    weeklyMap.set(weekDate, { date: weekDate })
                }
                const point = weeklyMap.get(weekDate)

                // Use the latest value for the week (since we iterate sorted by date, this naturally happens)
                const normalizedReturn = baseNav ? (h.cumulative_nav - baseNav) / baseNav : 0

                point[fund.record_id] = normalizedReturn
                point[`${fund.record_id}_yearly`] = normalizedReturn
                    < div className = "space-y-8" >
                        {/* 1. æ ¸å¿ƒæŒ‡æ ‡ */ }
                        < div className = "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6" >
                <MetricCard
                    title="æ€»è§„æ¨¡"
                    value={data.totalAssets}
                    format="currency"
                    className="col-span-1"
                />
                <MetricCard
                    title="ä»Šæ—¥æ”¶ç›Š"
                    value={data.todayReturn}
                    change={data.todayReturn}
                    format="currency"
                    className="col-span-1"
                />
                <MetricCard
                    title="æœ¬å‘¨æ”¶ç›Šç‡"
                    value={data.weeklyReturn}
                    format="percent"
                    className="col-span-1"
                />
                <MetricCard
                    title="æœ¬å¹´æ”¶ç›Šç‡"
                    value={data.annualReturn}
                    format="percent"
                    className="col-span-1"
                />
                <MetricCard
                    title="ç´¯è®¡æ”¶ç›Šç‡"
                    value={data.totalReturn}
                    format="percent"
                    className="col-span-1"
                />
            </div >

        {/* 2. è¿‘æœŸäº‹ä»¶æç¤º */ }
        < Card >
                <CardHeader>
                    <CardTitle>ğŸ”” è¿‘æœŸäº‹ä»¶æç¤º</CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="space-y-2">
                        <div className="p-3 bg-yellow-50 border border-yellow-200 rounded-md text-yellow-800 text-sm">
                            <span className="font-bold">æç¤º:</span> æ™¯æ—èµ„äº§å‡€å€¼æ›´æ–°å»¶è¿Ÿ (2025-11-20)
                        </div>
                        <div className="p-3 bg-blue-50 border border-blue-200 rounded-md text-blue-800 text-sm">
                            <span className="font-bold">ä¿¡æ¯:</span> æ–°å¢ 3 åªåŸºé‡‘äº§å“ (2025-11-19)
                        </div>
                    </div>
                </CardContent>
            </Card >

        {/* 3. æ”¶ç›Šç‡æ›²çº¿ */ }
        < Card >
                <CardHeader>
                    <div className="flex flex-col space-y-4 w-full">
                        <div className="flex items-center justify-between">
                            <CardTitle>ğŸ“ˆ æ”¶ç›Šç‡æ›²çº¿</CardTitle>
                        </div>
                        <div className="flex flex-wrap gap-2">
                            <button
                                onClick={() => setSelectedStrategy('all')}
                                className={`px-3 py-1 text-sm rounded-full transition-colors ${selectedStrategy === 'all'
                                    ? 'bg-blue-600 text-white'
                                    : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                    }`}
                            >
                                å…¨éƒ¨ç­–ç•¥
                            </button>
                            {STRATEGY_TYPES.map((strategy) => (
                                <button
                                    key={strategy}
                                    onClick={() => setSelectedStrategy(strategy)}
                                    className={`px-3 py-1 text-sm rounded-full transition-colors ${selectedStrategy === strategy
                                        ? 'bg-blue-600 text-white'
                                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                        }`}
                                >
                                    {strategy}
                                </button>
                            ))}
                        </div>
                    </div>
                </CardHeader>
                <CardContent>
                    <YieldCurveChart data={chartData} series={series} />
                </CardContent>
            </Card >

        {/* 4. ç­–ç•¥åˆ†å¸ƒ */ }
        < div className = "grid grid-cols-1 lg:grid-cols-2 gap-6" >
                <Card>
                    <CardHeader>
                        <CardTitle>ğŸ¥§ ç­–ç•¥åˆ†å¸ƒ</CardTitle>
                    </CardHeader>
                    <CardContent>
                        {/* Placeholder for Pie Chart */}
                        <div className="h-[300px] flex items-center justify-center text-gray-400">
                            ç­–ç•¥åˆ†å¸ƒå›¾è¡¨åŒºåŸŸ
                        </div>
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader>
                        <CardTitle>ğŸ“Š èµ„äº§é…ç½®</CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="h-[300px] flex items-center justify-center text-gray-400">
                            æš‚æ— è¯¦ç»†é…ç½®æ•°æ®
                        </div>
                    </CardContent>
                </Card>
            </div >
        </div >
    )
}
